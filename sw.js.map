{"mappings":"ACEA,IAAM,WAAa,0BAIb,YAAc,CAClB,IACA,eACA,cACA,cACA,kBACA,qBACA,qBACA,kBAGD,CAID,KAAK,gBAAgB,CAAC,UAAW,AAAC,IAChC,QAAQ,GAAG,CAAC,+CAEZ,EAAM,SAAS,CACb,OAAO,IAAI,CAAC,YACT,IAAI,CAAC,AAAC,IACL,QAAQ,GAAG,CAAC,iCAAkC,YAEvC,EAAM,MAAM,CAAC,eAErB,IAAI,CAAC,KACJ,QAAQ,GAAG,CAAC,4DAEL,KAAK,WAAW,KAExB,KAAK,CAAC,AAAC,IACN,QAAQ,KAAK,CAAC,kDAAmD,EACnE,GAEN,GAKA,KAAK,gBAAgB,CAAC,WAAY,AAAC,IACjC,QAAQ,GAAG,CAAC,gDACZ,EAAM,SAAS,CACb,OAAO,IAAI,GAAG,IAAI,CAAC,AAAC,GACX,QAAQ,GAAG,CAChB,EAAW,GAAG,CAAC,AAAC,IAEd,GAAI,IAAc,WAEhB,OADA,QAAQ,GAAG,CAAC,uCAAwC,GAC7C,OAAO,MAAM,CAAC,EAEzB,KAED,IAAI,CAAC,KACN,QAAQ,GAAG,CAAC,sCAEL,KAAK,OAAO,CAAC,KAAK,KAG/B,GAMA,KAAK,gBAAgB,CAAC,QAAS,AAAC,IAE9B,EAAM,WAAW,CACf,OAAO,KAAK,CAAC,EAAM,OAAO,EACvB,IAAI,CAAC,AAAC,GAEL,AAAI,GAOG,MAAM,EAAM,OAAO,EAAE,IAAI,CAC5B,AAAC,IAGG,GAAI,GAAmB,AAA2B,MAA3B,EAAgB,MAAM,EAErC,CAAC,EAAM,OAAO,CAAC,GAAG,CAAC,QAAQ,CAAC,cAAgB,CAAC,EAAM,OAAO,CAAC,GAAG,CAAC,QAAQ,CAAC,qBAAsB,CAC9F,IAAI,EAAkB,EAAgB,KAAK,GAC3C,OAAO,IAAI,CAAC,YACP,IAAI,CAAC,AAAA,IAEF,EAAM,GAAG,CAAC,EAAM,OAAO,CAAE,EAC7B,EACR,CAEJ,OAAO,CACX,GACF,KAAK,CAAC,AAAA,IAEJ,QAAQ,KAAK,CAAC,iCAAkC,EAIpD,IAGR","sources":["<anon>","sw.js"],"sourcesContent":["// sw.js - Service Worker พื้นฐานสำหรับ Cache ไฟล์\nconst CACHE_NAME = '3in1-spinner-cache-v2.5'; // ตั้งชื่อ Cache (เปลี่ยน v1 เป็น v2, v3... ถ้ามีการอัปเดตไฟล์ Cache ครั้งใหญ่)\n// รายชื่อไฟล์หลักๆ ที่จะ Cache ไว้ตอนติดตั้ง Service Worker\n// ใช้ Path แบบ Relative './' เหมือนเดิม\nconst urlsToCache = [\n    '.',\n    './index.html',\n    './style.css',\n    './script.js',\n    './manifest.json',\n    './icon-192x192.png',\n    './icon-512x512.png',\n    './promptpay.png' // พร้อมเพย์-โลโก้\n];\n// --- Event: install ---\n// เกิดขึ้นตอนติดตั้ง Service Worker ครั้งแรก\nself.addEventListener('install', (event)=>{\n    console.log('[Service Worker] Install event in progress.');\n    // รอให้การเปิด Cache และ Cache ไฟล์เสร็จก่อน ค่อยติดตั้งสำเร็จ\n    event.waitUntil(caches.open(CACHE_NAME) // เปิด Cache ตามชื่อที่ตั้งไว้\n    .then((cache)=>{\n        console.log('[Service Worker] Opened cache:', CACHE_NAME);\n        // เพิ่มไฟล์ทั้งหมดใน urlsToCache ลงใน Cache\n        return cache.addAll(urlsToCache);\n    }).then(()=>{\n        console.log('[Service Worker] All required files cached successfully!');\n        // บังคับให้ Service Worker ใหม่เริ่มทำงานทันที (แทนที่จะรอหน้าเก่าปิด)\n        return self.skipWaiting();\n    }).catch((error)=>{\n        console.error('[Service Worker] Caching failed during install:', error);\n    }));\n});\n// --- Event: activate ---\n// เกิดขึ้นหลังจากติดตั้งเสร็จ และ Service Worker เก่า (ถ้ามี) ถูกปิดไปแล้ว\n// ใช้สำหรับลบ Cache เก่าที่ไม่ต้องการแล้ว\nself.addEventListener('activate', (event)=>{\n    console.log('[Service Worker] Activate event in progress.');\n    event.waitUntil(caches.keys().then((cacheNames)=>{\n        return Promise.all(cacheNames.map((cacheName)=>{\n            // ถ้าชื่อ Cache ไม่ตรงกับ CACHE_NAME ปัจจุบัน ให้ลบทิ้ง\n            if (cacheName !== CACHE_NAME) {\n                console.log('[Service Worker] Deleting old cache:', cacheName);\n                return caches.delete(cacheName);\n            }\n        }));\n    }).then(()=>{\n        console.log('[Service Worker] Claiming clients.');\n        // ทำให้ Service Worker ควบคุมหน้าเว็บที่เปิดอยู่ทันที\n        return self.clients.claim();\n    }));\n});\n// --- Event: fetch ---\n// เกิดขึ้นทุกครั้งที่มี Request เกิดขึ้นจากหน้าเว็บ (โหลดรูป, CSS, JS, API)\n// เราจะดัก Request แล้วเช็คว่ามีใน Cache มั้ย (Cache-First Strategy)\nself.addEventListener('fetch', (event)=>{\n    // console.log('[Service Worker] Fetching:', event.request.url);\n    event.respondWith(caches.match(event.request) // ลองหา Request นี้ใน Cache\n    .then((cachedResponse)=>{\n        // ถ้าเจอใน Cache -> ส่งค่าจาก Cache กลับไปเลย (เร็ว + Offline ได้)\n        if (cachedResponse) // console.log('[Service Worker] Found in cache:', event.request.url);\n        return cachedResponse;\n        // ถ้าไม่เจอใน Cache -> ไปโหลดจาก Network ตามปกติ\n        // console.log('[Service Worker] Not found in cache, fetching from network:', event.request.url);\n        return fetch(event.request).then((networkResponse)=>{\n            // (Optional แต่แนะนำ) ถ้าโหลดจาก Network สำเร็จ ให้เอา Response นั้นไปเก็บใน Cache ด้วย เผื่อใช้ครั้งหน้า\n            // ต้อง clone() response ก่อน เพราะ response ใช้ได้ครั้งเดียว\n            if (networkResponse && networkResponse.status === 200) // เช็คว่าเป็น request ที่เราอยาก cache ไหม (เช่น ไม่ cache request ไปยัง googleapis หรือ apps script)\n            {\n                if (!event.request.url.includes('googleapi') && !event.request.url.includes('script.google.com')) {\n                    let responseToCache = networkResponse.clone();\n                    caches.open(CACHE_NAME).then((cache)=>{\n                        // console.log('[Service Worker] Caching new resource:', event.request.url);\n                        cache.put(event.request, responseToCache);\n                    });\n                }\n            }\n            return networkResponse; // ส่ง Response จาก Network กลับไป\n        }).catch((error)=>{\n            // ถ้าโหลดจาก Network ก็ไม่ได้ (เช่น Offline)\n            console.error('[Service Worker] Fetch failed:', error);\n        // อาจจะส่งหน้า Offline fallback กลับไปก็ได้\n        // return caches.match('./offline.html'); // ต้องสร้างไฟล์ offline.html ไว้ด้วย\n        // หรือแค่ปล่อยให้มัน Error ไปตามปกติ\n        });\n    }));\n});\n\n//# sourceMappingURL=sw.js.map\n","// sw.js - Service Worker พื้นฐานสำหรับ Cache ไฟล์\r\n\r\nconst CACHE_NAME = '3in1-spinner-cache-v2.5'; // ตั้งชื่อ Cache (เปลี่ยน v1 เป็น v2, v3... ถ้ามีการอัปเดตไฟล์ Cache ครั้งใหญ่)\r\n\r\n// รายชื่อไฟล์หลักๆ ที่จะ Cache ไว้ตอนติดตั้ง Service Worker\r\n// ใช้ Path แบบ Relative './' เหมือนเดิม\r\nconst urlsToCache = [\r\n  '.', // หมายถึง index.html ใน root\r\n  './index.html', // ใส่ index.html เต็มๆ ไปด้วยก็ได้ เผื่อบาง Browser\r\n  './style.css',\r\n  './script.js',\r\n  './manifest.json',\r\n  './icon-192x192.png', // ไอคอนที่มึงสร้าง\r\n  './icon-512x512.png',  // ไอคอนที่มึงสร้าง\r\n  './promptpay.png'  // พร้อมเพย์-โลโก้\r\n  // เพิ่มไฟล์อื่นๆ ที่จำเป็น เช่น รูปภาพอื่นๆ, Font ที่โหลดเอง (ถ้ามี)\r\n  // พวกไฟล์จาก CDN (Firebase SDK, Font Awesome) อาจจะไม่ต้อง Cache เองก็ได้ ให้ Browser จัดการ\r\n];\r\n\r\n// --- Event: install ---\r\n// เกิดขึ้นตอนติดตั้ง Service Worker ครั้งแรก\r\nself.addEventListener('install', (event) => {\r\n  console.log('[Service Worker] Install event in progress.');\r\n  // รอให้การเปิด Cache และ Cache ไฟล์เสร็จก่อน ค่อยติดตั้งสำเร็จ\r\n  event.waitUntil(\r\n    caches.open(CACHE_NAME) // เปิด Cache ตามชื่อที่ตั้งไว้\r\n      .then((cache) => {\r\n        console.log('[Service Worker] Opened cache:', CACHE_NAME);\r\n        // เพิ่มไฟล์ทั้งหมดใน urlsToCache ลงใน Cache\r\n        return cache.addAll(urlsToCache);\r\n      })\r\n      .then(() => {\r\n        console.log('[Service Worker] All required files cached successfully!');\r\n        // บังคับให้ Service Worker ใหม่เริ่มทำงานทันที (แทนที่จะรอหน้าเก่าปิด)\r\n        return self.skipWaiting();\r\n      })\r\n      .catch((error) => {\r\n        console.error('[Service Worker] Caching failed during install:', error);\r\n      })\r\n  );\r\n});\r\n\r\n// --- Event: activate ---\r\n// เกิดขึ้นหลังจากติดตั้งเสร็จ และ Service Worker เก่า (ถ้ามี) ถูกปิดไปแล้ว\r\n// ใช้สำหรับลบ Cache เก่าที่ไม่ต้องการแล้ว\r\nself.addEventListener('activate', (event) => {\r\n  console.log('[Service Worker] Activate event in progress.');\r\n  event.waitUntil(\r\n    caches.keys().then((cacheNames) => {\r\n      return Promise.all(\r\n        cacheNames.map((cacheName) => {\r\n          // ถ้าชื่อ Cache ไม่ตรงกับ CACHE_NAME ปัจจุบัน ให้ลบทิ้ง\r\n          if (cacheName !== CACHE_NAME) {\r\n            console.log('[Service Worker] Deleting old cache:', cacheName);\r\n            return caches.delete(cacheName);\r\n          }\r\n        })\r\n      );\r\n    }).then(() => {\r\n      console.log('[Service Worker] Claiming clients.');\r\n      // ทำให้ Service Worker ควบคุมหน้าเว็บที่เปิดอยู่ทันที\r\n      return self.clients.claim();\r\n    })\r\n  );\r\n});\r\n\r\n\r\n// --- Event: fetch ---\r\n// เกิดขึ้นทุกครั้งที่มี Request เกิดขึ้นจากหน้าเว็บ (โหลดรูป, CSS, JS, API)\r\n// เราจะดัก Request แล้วเช็คว่ามีใน Cache มั้ย (Cache-First Strategy)\r\nself.addEventListener('fetch', (event) => {\r\n  // console.log('[Service Worker] Fetching:', event.request.url);\r\n  event.respondWith(\r\n    caches.match(event.request) // ลองหา Request นี้ใน Cache\r\n      .then((cachedResponse) => {\r\n        // ถ้าเจอใน Cache -> ส่งค่าจาก Cache กลับไปเลย (เร็ว + Offline ได้)\r\n        if (cachedResponse) {\r\n          // console.log('[Service Worker] Found in cache:', event.request.url);\r\n          return cachedResponse;\r\n        }\r\n\r\n        // ถ้าไม่เจอใน Cache -> ไปโหลดจาก Network ตามปกติ\r\n        // console.log('[Service Worker] Not found in cache, fetching from network:', event.request.url);\r\n        return fetch(event.request).then(\r\n            (networkResponse) => {\r\n                // (Optional แต่แนะนำ) ถ้าโหลดจาก Network สำเร็จ ให้เอา Response นั้นไปเก็บใน Cache ด้วย เผื่อใช้ครั้งหน้า\r\n                // ต้อง clone() response ก่อน เพราะ response ใช้ได้ครั้งเดียว\r\n                if (networkResponse && networkResponse.status === 200) { // เช็คว่าโหลดสำเร็จจริง\r\n                    // เช็คว่าเป็น request ที่เราอยาก cache ไหม (เช่น ไม่ cache request ไปยัง googleapis หรือ apps script)\r\n                    if (!event.request.url.includes('googleapi') && !event.request.url.includes('script.google.com')) {\r\n                        let responseToCache = networkResponse.clone();\r\n                        caches.open(CACHE_NAME)\r\n                            .then(cache => {\r\n                                // console.log('[Service Worker] Caching new resource:', event.request.url);\r\n                                cache.put(event.request, responseToCache);\r\n                            });\r\n                    }\r\n                }\r\n                return networkResponse; // ส่ง Response จาก Network กลับไป\r\n            }\r\n        ).catch(error => {\r\n            // ถ้าโหลดจาก Network ก็ไม่ได้ (เช่น Offline)\r\n            console.error('[Service Worker] Fetch failed:', error);\r\n            // อาจจะส่งหน้า Offline fallback กลับไปก็ได้\r\n            // return caches.match('./offline.html'); // ต้องสร้างไฟล์ offline.html ไว้ด้วย\r\n            // หรือแค่ปล่อยให้มัน Error ไปตามปกติ\r\n        });\r\n      })\r\n  );\r\n});\r\n"],"names":["CACHE_NAME","urlsToCache","self","addEventListener","event","console","log","waitUntil","caches","open","then","cache","addAll","skipWaiting","catch","error","keys","cacheNames","Promise","all","map","cacheName","delete","clients","claim","respondWith","match","request","cachedResponse","fetch","networkResponse","status","url","includes","responseToCache","clone","put"],"version":3,"file":"sw.js.map"}